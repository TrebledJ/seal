package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, Match => AmyMatch, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._
import scala.util.matching.Regex.Match

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      // Helper for generating short-circuiting code on branches.
      def cgIfElse(cond: Expr, eThen: Expr, eElse: Expr): Code = {
        def cgBranch(cond: Expr, nThen: String, nElse: String): Code = {
          cond match {
            case BooleanLiteral(true) => Br(nThen)
            case BooleanLiteral(false) => Br(nElse)
            case Not(e) => cgBranch(e, nElse, nThen)
            case AmyAnd(lhs, rhs) =>
              val nLong = getFreshLabel()
              Block(nLong)
              <:> cgBranch(lhs, nLong, nElse) // Jump directly to nElse if false.
              <:> End
              <:> cgBranch(rhs, nThen, nElse)
            case AmyOr(lhs, rhs) =>
              val nLong = getFreshLabel()
              Block(nLong)
              <:> cgBranch(lhs, nThen, nLong) // Jump directly to nThen if true.
              <:> End
              <:> cgBranch(rhs, nThen, nElse)
            case _ => // Not a boolean expression. Codegen it first.
              cgExpr(cond)
              <:> If_void
                <:> Br(nThen)
              <:> Else
                <:> Br(nElse)
              <:> End
          }
        }

        val nAfter = getFreshLabel()
        val nThen = getFreshLabel()
        val nElse = getFreshLabel()
        Block(nAfter)
          <:> Block(nElse)
            <:> Block(nThen)
              <:> cgBranch(cond, nThen, nElse)
            <:> End // nThen:
              <:> Comment(nThen)
            <:> cgExpr(eThen)
            <:> Br(nAfter)
          <:> End // nElse:
            <:> Comment(nElse)
          <:> cgExpr(eElse)
        <:> End // nAfter:
          <:> Comment(nAfter)
      }

      expr match {
        case IntLiteral(value) => Const(value)
        case BooleanLiteral(value) => Const(if value then 1 else 0)
        case StringLiteral(value) => mkString(value)
        case UnitLiteral() => Const(0) // Value shouldn't matter. Type checker should have ensured that.
        case Variable(name) => GetLocal(locals(name))
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        // case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> And
        // case AmyOr(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Or
        case AmyAnd(lhs, rhs) => cgIfElse(expr, BooleanLiteral(true), BooleanLiteral(false))
        case AmyOr(lhs, rhs) => cgIfElse(expr, BooleanLiteral(true), BooleanLiteral(false))
        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")

        case Not(e) => cgExpr(e) <:> Eqz // If False (0) => then 0 == 0, so it becomes True. Otherwise, False.
        case Neg(e) => cgExpr(e) <:> Const(-1) <:> Mul // ¯\_(ツ)_/¯

        case Tuple(_) => ???
        case Lambda(_, _, _) => ???
        case AmyCall(expr, args) => ???
          // // Generates constraints for a signature.
          // def callFunction(sig: FunSig): Code = {
          //   // ctx.reporter.info(s"AmyCall with qname=${qname} has full name ${fullName(sig.owner, qname)}")
          //   args.map(cgExpr)
          //     <:> Call(fullName(sig.owner, qname))
          // }

          // def mkADT(sig: ConstrSig): Code = {
          //   // Process of allocating an ADT value.
          //   // 1. Save the old memory boundary b
          //   // 2. Increment the current memory boundary by the size of the allocated ADT value
          //   // 3. Store the constructor index to address b
          //   // 4. For each field of the constructor, generate code for it and store it in memory in the correct offset from b
          //   // 5. Push b to the stack (base address of the ADT)
          //   val b = lh.getFreshLocal()
          //   val sizeofADT = 4 * (1 + sig.argTypes.length) // 1 to represent the ctor, the rest to represent the fields.

          //   def cgField(expr: Expr, index: Int): Code =
          //     GetLocal(b)
          //     <:> adtField(index)
          //     <:> cgExpr(expr)
          //     <:> Store

          //   // 1.
          //   GetGlobal(memoryBoundary)
          //   <:> SetLocal(b)
          //   // 2.
          //   <:> GetGlobal(memoryBoundary)
          //   <:> Const(sizeofADT)
          //   <:> Add
          //   <:> SetGlobal(memoryBoundary)
          //   // 3.
          //   <:> GetLocal(b)
          //   <:> Const(sig.index) // Use the constructor's index as representation.
          //   <:> Store
          //   // 4.
          //   <:> args.zipWithIndex.map(cgField)
          //   // 5.
          //   <:> GetLocal(b)
          // }

          // table.getFunction(qname) match {
          //   case Some(funcSig) =>
          //     callFunction(funcSig)
          //   case None =>
          //     table.getConstructor(qname) match {
          //       case Some(constrSig) => 
          //         mkADT(constrSig)
          //       case None =>
          //         ctx.reporter.fatal("call is neither function call nor constructor call")
          //     }
          // }

        case Sequence(e1, e2) =>
          cgExpr(e1) 
          <:> Drop // Discard result.
          <:> cgExpr(e2)

        case Let(df, value, body) =>
          val local = lh.getFreshLocal();
          cgExpr(value)
          <:> SetLocal(local) // Unlike Sequence, save the result as a local.
          <:> cgExpr(body)(locals + (df.name -> local), lh)

        case Ite(cond, thenn, elze) =>
          cgExpr(cond)
          <:> If_i32
            <:> cgExpr(thenn)
          <:> Else
            <:> cgExpr(elze)
          <:> End

        // TODO: give up
        case AmyMatch(scrut, cases) =>
          // Code gen:
          // 1. Evaluate `scrut` and store result on stack.
          // 2. Fold over the match cases, converting each one to an If-block.
          //    Base: `error("Match error!")`.
          //    Fold right (cases on right get wrapped first):
          //      (acc: Code, mcase: MatchCase) =>
          //        -> Try match `mcase` with `scrut`. (See A.)
          //        -> If (i32)
          //        ->   Match success! Bind locals.
          //        ->   cgExpr(mcase.expr)(newlocals, lh)
          //        -> Else
          //        ->   acc
          //        -> End
          // 
          // A. Matching `mcase` with `scrut`:
          //    Call `matchAndBind(mcase.pat, scrut)`.
          //    1. matchAndBind(_, v) => Put true (Const 1) on stack.
          //    2. matchAndBind(id, v) => Introduce new local; id -> scrut. Put true (Const 1) on stack.
          //    3. matchAndBind(lit, v) => Check if literals match. (Beware string literals.)
          //        Put true (Const 1) if equal. False (Const 0) otherwise.
          //    4. matchAndBind(C1(a0, ..., an), C2(v0, ..., vm)) =>
          //        - Load `scrut` onto stack (assume `scrut` is the address of some ADT value).
          //        - Load value pointed by `scrut` (C2).
          //        - Check if value is same as index of C1.
          //        - If (i32)
          //          - Codegen parameters by folding right:
          //            - (acc: Code, (pat, i): (Pattern, Int)) =>
          //                -> matchAndBind( scrut[i], {MatchCase(a[i], true), MatchCase(_, false)} )
          //                -> If (i32)
          //                ->   acc
          //                -> Else
          //                ->   False (Const 0)
          //                -> End
          //        - Else
          //          - Put false (Const 0) on stack.
          //        - End

          val matchErrorCode = cgExpr(Error(StringLiteral("Match error!")))
          val scrutTopLocal = lh.getFreshLocal()

          def casefold(mcase: MatchCase, acc: Code): Code = {
            val (code, bindings) = matchAndBind(mcase.pat, scrutTopLocal)
            code
            <:> If_i32
              <:> cgExpr(mcase.expr)(locals ++ bindings, lh)
            <:> Else
              <:> acc
            <:> End
          }

          // Construct the code to match a pattern. Returns the code along with new bindings and updated locals handler.
          type Bindings = Map[Identifier, Int]
          def matchAndBind(pat: Pattern, scrutLocal: Int): (Code, Bindings) = {
            val fieldLocal = lh.getFreshLocal()

            def constrfold(x: (Pattern, Int), acc: (Code, Bindings)): (Code, Bindings) = {
              val (pat, i) = x
              // val local = lh.getFreshLocal()
              val (accCode, accBindings) = acc
              val (mabCode, bindings) = matchAndBind(pat, fieldLocal)

              val code =
                GetLocal(scrutLocal)
                <:> adtField(i)
                <:> Load  // Get value stored at ADT field.
                <:> SetLocal(fieldLocal)
                <:> mabCode // Recurse (and bind) scrut field with sub pattern.
                <:> If_i32
                  <:> accCode
                <:> Else
                  <:> Const(0)
                <:> End
              
              (code, bindings ++ accBindings)
            }

            pat match {
              case WildcardPattern() => (Const(1), Map())
              case IdPattern(name) =>
                val local = lh.getFreshLocal()
                val code = GetLocal(scrutLocal) <:> SetLocal(local) <:> Const(1)
                (code, Map(name -> local))
              case LiteralPattern(lit) =>
                val code = GetLocal(scrutLocal)
                  <:> cgExpr(lit)
                  <:> Eq // Ok with strings: will compare pointers.
                (code, Map())
              case CaseClassPattern(constr, args: List[Pattern]) =>
                val init: (Code, Bindings) = (Const(1), Map())
                val (code, bindings) = args.zipWithIndex.foldRight(init)(constrfold)

                GetLocal(scrutLocal)
                <:> Load // Load constructor stored by scrut.
                <:> Const(table.getConstructor(constr).get.index) // Load index of constructor in pattern.
                <:> Eq // Check if constructors are equal.
                <:> If_i32 <:> Comment("try matching pattern " ++ table.getConstructor(constr).get.toString)
                  <:> code
                <:> Else
                  <:> Const(0) // No match.
                <:> End
                (code, bindings)
              case TuplePattern(_) => ???
            }
          }
          
          cgExpr(scrut)
          <:> SetLocal(scrutTopLocal) // Save it first, in case we need it multiple times (e.g. multiple Class patterns).
          <:> cases.foldRight(matchErrorCode)(casefold)


        case Error(msg) =>
          // Prepend "Error: " and print.
          cgExpr(StringLiteral("Error: "))
          <:> cgExpr(msg)
          <:> Call("String_concat")
          <:> Call("Std_printString")
          <:> Unreachable
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
